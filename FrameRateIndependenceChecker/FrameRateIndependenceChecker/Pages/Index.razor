@inject NavigationManager navigationManager
@page "/"
@using ChartJs.Blazor.LineChart
@using ChartJs.Blazor.ScatterChart

<h1>Frame Rate Independence Checker</h1>
Check if your code is actually frame-rate independent.<br />
                                                      <br />
Fill in the body of the method below (in C#), and set the <code>value</code> field. Use <code>deltaTime</code> as part of your calculations.<br />
When you're ready, press go. More info below.
<br />
<br />

<div class="codezone">
public static float value;<br/>
public void Update(float deltaTime)<br/>{
<textarea @bind="InputCode" rows="5" class="md-textarea form-control inputcode"></textarea>
}
</div>

<br />

<button type="button" class="btn btn-primary btn-lg btn-block" @onclick="TrySomethingOut">Run</button>

<br />

<div class="chartzone">
    <Chart Config="chartConfig"></Chart>
</div>

<br />
<br />


This page simulates running an update function at different framerates, in order to test how framerate-independant an expression is.<br/><br/>

To test 30FPS, it goes through and evaluates the function 30 times, passing 1/30 as deltaTime and records the value at each iteration. It then does the same with 60FPS, 90FPS, 144FPS and 240FPS. It then plots the results onto a graph.<br/><br/>

Ideally, if the code is truely framerate independant, then each iteration will produce the same curve on the graph. If it is not, then the curves will deviate from each other.

C# Compilation code heavily based on <a href="https://www.strathweb.com/2019/06/building-a-c-interactive-shell-in-a-browser-with-blazor-webassembly-and-roslyn/">this article</a> by <a href="https://twitter.com/filip_woj">Filip W</a>. Charts are made using <a href="https://www.nuget.org/packages/ChartJs.Blazor/">ChartJs.Blazor</a>.

@code{
    public string InputCode = "var target = 100;\nvar diff = (target - value);\nvalue += diff* 10 * deltaTime;";

    public CodeCompiler codeChecker = new CodeCompiler();

    private ScatterConfig chartConfig = new ScatterConfig()
    {
        Options = new LineOptions()
        {
            Title = new OptionsTitle() { Display = true, Text = "Results" },
        },
    };

    protected async override Task OnInitializedAsync()
    {
        await codeChecker.OnInitializedAsync(navigationManager.BaseUri);
    }

    public async Task TrySomethingOut()
    {
        chartConfig.Data.Datasets.Clear();

        var actualCode = "using System; public class MainThing { public static float value {get;set;}\n public static void Update(float deltaTime) { " + InputCode + "; } }";
        Console.WriteLine("Input:" + actualCode);
        var snippet = await codeChecker.Compile(actualCode);

        if (snippet != null)
        {
            await TestAndPlot(snippet, 30, 0);
            await TestAndPlot(snippet, 60, 1);
            await TestAndPlot(snippet, 90, 2);
            await TestAndPlot(snippet, 144, 3);
            await TestAndPlot(snippet, 240, 4);
        }
    }

    public string[] Colors = new string[] { "rgb(180, 255, 173)", "rgb(255, 246, 158)", "rgb(255, 174, 150)", "rgb(255, 147, 205)", "rgb(211, 158, 255)" };

    private async Task TestAndPlot(CompiledSnippet snippet, float fps, int ind)
    {
        Console.WriteLine(ColorUtil.RandomColorString());
        var fpsRunner = new FpsRunner(snippet, fps);
        var results = await fpsRunner.Test(1f);

        var color = Colors[ind];

        var dataSet = new ScatterDataset(results.Select(kvp => new Point(kvp.Key, kvp.Value)))
        {
            Label = fps + "FPS",
            BackgroundColor = color,
            PointBackgroundColor = color,
            BorderColor = color,
            PointBorderColor = color,
            PointHoverBackgroundColor = color,

            ShowLine = true,

            Fill = false
        };

        chartConfig.Data.Datasets.Add(dataSet);
    }
}
